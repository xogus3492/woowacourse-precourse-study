*이 내용은 [우아한테크코스 클린코드 원칙](https://github.com/woowacourse/woowacourse-docs/blob/main/cleancode/pr_checklist.md)을 기반으로 작성했습니다.
<br><br>
## 1. 한 메서드에 오직 한 단계의 들여쓰기(indent)만 허용했는가?

if, for, while 등 메서드 내부에 블럭이 추가 될때 인덴트 수준이 1씩 증가한다.

인덴트 수준이 깊어질수록 코드가 복잡해지고 메서드가 여러가지 일을 수행하고 있다는 증거이다. 메서드는 각자 한 가지 일만 담당해야하는 원칙을 고수하며 메서드 분리를 통해 인덴트 수준을 낮춘다. 그리고 인덴트 수준을 낮춰 코드의 가독성과 유지보수성을 높이자.

Q : **인덴트 수준을 지키기 위해 메소드가 방대하게 많아져도 괜찮은가?**<br>
A : **메소드가 방대하게 많아진다면 단일책임원칙이 위배되지 않았은지 점검해 봐라.**

<hr>

## 2. else 예약어를 쓰지 않았는가?

직관적인 코드를 짜기 위해서 else를 지양할 필요가 있다. if문에 else문이 덧붙여진다면 가독성이 떨어질 수 있고 유지보수성도 떨어진다. 따라서 return을 활용하여 else문을 사용하지 않고 조건에 따른 값을 반환할 수 있도록 구현하자.

<hr>

## 3. 모든 원시값과 문자열을 포장했는가?

원시값과 문자열을 포장한 객체는 값에 대해 단순 자료형의 값이 아닌 구체적인 정체성을 부여해준다. 그리하여 포장한 객체마다 각자의 행위를 명세할 수 있고 유효성 검사와 같은 유니크한 행위에 대해서 자체적으로 지닐 수 있는 장점이 있다. 이로써 각각의 요소에만 집중할 수 있어 책임관계가 명확해지고 유지보수성이 증가한다.

- (일급 컬렉션/wrapper 객체 제외) 3개 이상의 인스턴스 변수가 존재하는 클래스를 쓰지 말자. 인스턴스 변수를 많이 가지는 클래스일수록 응집도가 떨어진다.

<hr>

## 4. 콜렉션에 대해 일급 콜렉션을 적용했는가?

원시값을 포장하는 것과 같이 콜렉션에 객체를 포장한 객체를 일급 콜렉션이라고 한다. 단, 일급 콜렉션은 콜렉션변수 이외에 다른 맴버 변수가 존재하면 안된다. 일급 콜렉션의 장점으로는 다음이 있다.

1. 비즈니스에 종속적인 자료구조<br>
콜렉션에 대한 예외처리를 서비스 로직에서 처리한다고 가정한다면 해당 예외처리 로직이 언제, 어떻게 쓰이는지 한 번에 파악하기 어렵다. 따라서 일급 컬렉션을 생상하여 내부에 콜렉션에 대한 예외처리를 구현하면 해당 콜렉션의 생성 조건을 단번에 알 수 있다.

2. 불변<br>
final 키워드는 재할당을 불가능하게 한다. 만약 값이 변하지 않는 불변한 콜렉션을 다루고 싶어서 콜렉션을 final 키워드로 선언한다고 해도 객체의 재할당만 불가능한 것이지 내부 데이터는 추가되고 삭제될 수 있다. 하지만 일급 콜렉션으로 기존 콜렉션에 대한 행위를 막고 필요한 행위만을 추가하여 불변한 콜렉션을 만들 수 있다.

3. 상태와 행위를 한곳에서 관리<br>
해당 콜렉션에 대한 행위를 외부에 구현한다면 재사용성이 떨어지고 후에 유지보수가 어려워진다. 따라서 행위를 일급 콜렉션 내부에 구현하여 행위에 대한 재사용성을 높이고 유지보수를 용이하게 한다.

4. 이름이 있는 콜렉션<br>
데이터의 종류는 같지만 성격이 다를 때(ex) naverPay와 kakaoPay) 변수명 만으로는 이 콜렉션의 의도를 파악하기 어렵다. 따라서 일급 콜렉션을 사용하여 이러한 경우의 모호함을 구체화한다.

<hr>

## 5. 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지 않았는가?

여기서 인스턴스 변수란 일급 컬렉션과 wrapper 객체를 제외한 인스턴스 변수를 의미한다. 

클래스는 책임이 적고 응집력있게 만들어야한다. 따라서 클래스에는 적은 인스턴스 변수를 가져야한다. 다음 순서에 따라 책임이 적고 응집력이 높은 클래스로 만들자.

1. 큰 함수를 작은 함수 여럿으로 나누자.<br>
작은 함수로 나누면 상위에서 주입한 인수를 다음 함수로 넘기는 모습을 볼 수 있다.

2. 인수를 그대로 다음 인수로 넘기는 게 많아진다면 인스턴스 변수로 승격시켜라.<br>
인스턴스 변수가 많아진다는 것은 클래스가 높은 응집도를 유지하기 어려워진다는 것이다.

3. 클래스가 응집력을 잃었나? 그렇다면 클래스를 쪼개라

**Q. 변수가 아주 많은 큰 함수 하나가 있다. 큰 함수 일부를 작은 함수 하나로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다. 그렇다면 변수 네 개를 함수 인자로 넣어서 사용해야할까?<br>
A. 아니다. 네 변수를 클래스의 인스턴스 변수로 승격한다면 새 함수는 인자가 필요없다.**

<hr>

## 6. getter/setter 없이 구현했는가?

- 핵심 로직을 구현하는 도메인 객체에 getter/setter를 쓰지 않고 구현했는가?
- 단, DTO는 허용한다.

DTO나 Controller 등에서 사용하기 위해 도메인 객체에 getter를 놓는 것은 상관 없다. 도메인 간의 getter 사용을 금지 하기 위함이다.

도메인 간 맴버 변수 참조를 금지하는 이유는 캡슐화를 지키면서 객체에게 메시지를 보내 스스로 상태에 대한 처리로직을 수행하도록 하기 위해서다. (괜히 private으로 선언하는 게 아니다.)

<hr>

## 7. 메소드의 인자 수를 제한했는가?

- 4개 이상의 인자는 허용하지 않는다.
- 3개도 가능하면 줄이기 위해 노력해 본다.

메소드의 인자 수가 많아질수록 가독성이 떨어지고 메소드의 역할을 파악하기 어려울 수 있으며 유지보수가 떨어진다. 또한 메소드가 많은 인자를 필요로 한다면 해당 클래스가 여러 역할을 하고 있지 않은지 의심을 해볼 수 있다. 메소드의 인자 수를 줄이기 버겁다면 로직을 분리하여 더 작게 만들어 보자.

<hr>

## 8. 코드 한 줄에 점(.)을 하나만 허용했는가?

- 디미터(Demeter)의 법칙(“친구하고만 대화하라”)을 지켰는가?
- 예를 들어 location.current.representation.substring(0, 1)와 같이 여러 개의 점(.)이 등장하면 리팩토링할 부분을 찾아본다.

한 객체가 자신이 조작하는 다른 객체에 대한 내부 정보(데이터)를 알고 있으면 안된다. 이는 캡슐화를 위반하고 객체 간 결합도를 높이는 불상사를 초래한다. 객체는 자신의 내부 정보를 제공하는 것보다 동작을 제공해야 한다.

```java
public class Person {
    private final PersonWallet personWallet;

    int getMoney() {
        return persenWallet.getPersonMoney().getMoney(); // 디미터 법칙 위반
    }
}

public class PersonWallet {
    private final PersonMoney personMoney;

    PersonMoney getPersonMoney() {
        return this.personMoney;
    }
}

public class PersonMoney {
    private final int money;

    int getMoney() {
        return this.money;
    }
}
```

따라서 다음과 같이 디미터 법칙을 적용한다.

```java
public class Person {
    private final PersonWallet personWallet;

    int getMoney() {
        return persenWallet.getMoney(); // 디미터 법칙 준수
    }
}

public class PersonWallet {
    private final PersonMoney personMoney;

    int getMoney() {
        return personMoney.getMoney;
    }
}

public class PersonMoney {
    private final int money;

    int getMoney() {
        return this.money;
    }
}
```

단, DTO와 자료구조 같은 경우에는 내부 구조가 외부에 노출되어야 하므로 디미터 법칙을 적용하지 않는다. 또한 Stream 등 체이닝을 하는 경우에도 디미터 법칙을 적용하지 않는다.

<hr>

## 9. 메소드가 한가지 일만 담당하도록 구현했는가?

메소드를 한가지 일만 담당하도록 구현하여 재사용성과 유지보수성을 높인다. 메소드를 분리하여 한가지 일만 하도록 만든다면 오류가 발생하거나 수정이 필요할 때 해당 부분을 금방 발견하여 해결할 수 있다.

<hr>

## 10. 클래스를 작게 유지하기 위해 노력했는가?

클래스를 작게 유지하라는 의미는 최종 목적에 대해 많은 책임을 갖지 말라, 즉 책임을 작게 하라는 의미이다. 그리고 이것은 SOLID 원칙 중 ‘하나의 객체는 반드시 하나의 기능만을 수행하는 책임을 갖는다’는 단일 책임 원칙과 일맥상 통한다. 클래스를 작게작게 분리해서 이러한 책임을 작게 하게 유지하기 위해 노력하자.

<hr>
